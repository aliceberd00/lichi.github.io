import Head from 'next/head'
import Image from 'next/image'
import { Inter } from 'next/font/google'
import styles from '@/styles/Home.module.css'
import {Card} from "@/components/card/Card";
import {useEffect, useState} from "react";
import UiVirtualScroll from "@/components/UiVirtualScroll/UiVirtualScroll";
import {useDispatch, useSelector} from "react-redux";
import {fetchItems} from "@/asyncActions/getItems";
import axios from "axios";


const inter = Inter({ subsets: ['latin'] })
const callApi = (offset, limit) => {
    return new Promise((resolve) => {
        const items = []
        for (let index = offset; index < offset + limit; index++) {
            items.push('label ' + index)
        }

        setTimeout(() => {
            resolve(items)
        }, 2000)
    })
}

const CheckHeadVisibility = (items_array) => {
  //получем данные из state в массив
    let result = false
    for (let i=0; i<=11; i++){
       if(items_array[i].visibility)
           result = true
    }
    return result
}

const CheckTailVisibility = (items_array) => {
    //получем данные из state в массив
    let result = false
    for (let i=24; i<=35; i++){
        console.log("otladka")
        console.log(items_array[i])
        if(items_array[i].visibility)
            result = true
    }
    return result
}

const getMaxPageNumber = (items_array) => {
    //на первом шаге получаем массив из state
    return (items_array[35].id + 1) / 12
}

export default function Home({items_array_statc}) {
    const dispatch = useDispatch()
    const limit = 12
    // количество элементов, которые мы хотим сохранить в памяти - 300
    const buffer = limit * 3
    // количество элементов, которые мы хотим кэшировать при загрузке нового фрагмента данных
    const cache = buffer - limit
    const [items, setItems] = useState([])
    const [isLoading, setIsLoading] = useState(false)
    const items_array = useSelector(state => state.items_reducer.items_array)

    useEffect(() => {
        setIsLoading(true)
        // callApi(0, buffer).then((res) => {
        //     setItems(res)
        //     setIsLoading(false)
        // })
        dispatch({type: "INSERT_ITEMS", payload: items_array_statc})
        setIsLoading(false)
    }, [])

     useEffect(() => {
         console.log(items_array)
         if (items_array.length > 0){
             if(CheckTailVisibility(items_array)){
                 console.log('added next data to tail')
                 // console.log(items_array)
                 const max_page = getMaxPageNumber(items_array)
                 console.log("max_page = " + max_page)
                 dispatch(fetchItems(12,max_page+1,'ADD_TO_TAIL'))
                 console.log('data tipa fetched')
            }
         }
     },[items_array]);


    const prevCallback = (newOffset) => {
        setIsLoading(true)

        return callApi(newOffset, limit).then((res) => {
            const newItems = [...res, ...items.slice(0, cache)]
            setItems(newItems)
            setIsLoading(false)
            return true
        })
    }

    const nextCallback = (newOffset) => {
        setIsLoading(true)

        return callApi(newOffset, limit).then((res) => {
            const newItems = [...items.slice(-cache), ...res]
            setItems(newItems)
            setIsLoading(false)
            return true
        })
    }

    let cards_strng = ''
    // if(items_array){
    //     cards_strng = items_array.map((item, index) => (
    //         <div>
    //             <Card name={item.name}
    //                   article={item.article}
    //                   price={item.price}
    //                   description={item.description}
    //                   img_link={item.img_link}
    //                   key={item.id}
    //             />
    //             {isLoading ? <>Loading...</> : item}
    //         </div>
    //     ))
    // }


  return (
    <>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className={`${styles.main} ${inter.className}`}>
        <div /*className={styles.description}*/>
            <button onClick={() => dispatch(fetchItems(30,1,'INSERT_ITEMS'))}>
                press me</button>

            <UiVirtualScroll
                buffer={buffer}
                rowHeight={39}
                height="90vh"
                limit={limit}
                onPrevCallback={prevCallback}
                onNextCallback={nextCallback}
            >
                <div className={styles.cards}>
                    {items_array.map(item =>
                        <div>
                            <Card id={item.id}
                                  name={item.name}
                                  article={item.article}
                                  price={item.price}
                                  description={item.description}
                                  img_link={item.img_link}
                                  key={item.id}
                            />
                            {/*{isLoading ? <>Loading...</> : item.id}*/}
                        </div>
                    )}
                    {cards_strng}
                </div>
            </UiVirtualScroll>

        </div>
      </main>
    </>
  )
}


export const getStaticProps = async () => {
    const response = await axios.get('https://api.lichi.com/category/get_category_product_list?' + new URLSearchParams({
        category: 'clothes',
        lang: 1,
        shop: 2,
        limit: 36,
        page: 1
    }))
    // console.log(response.data)
    const data = response.data
    const data_array = data.api_data.aProduct
    let result_array = []
    for (let i=0; i<data_array.length; i++){
        const one_element = {
            id: i ,
            visibility: false,
            name: data_array[i].name,
            article: data_array[i].article,
            price: data_array[i].original_price + data_array[i].currency.postfix,
            description: data_array[i].descriptions.html,
            img_link: data_array[i].photos[0].big
        }
        result_array.push(one_element)
    }

    return {
        props: {
            items_array_statc: result_array
        },
        revalidate: 60,
    }
}

