import Head from 'next/head'
import { Inter } from 'next/font/google'
import styles from '@/styles/Home.module.css'
import {Card} from "@/components/card/Card";
import {useEffect, useState, useRef} from "react";
import {useDispatch, useSelector} from "react-redux";
import {fetchItems, axiosFetchItems} from "@/asyncActions/getItems";
import axios from "axios";

const inter = Inter({ subsets: ['latin'] })


//Нам нужны функции для проверки - сейчас происходит просмотр первой (Head), второй (Middle) или последней (Tail) части списка
const CheckHeadVisibility = (items_array) => {
  //получем данные из state в массив
    let result = false
    for (let i=0; i<=11; i++){
       if(items_array[i].visibility)
           result = true
    }
    return result
}

const CheckMiddleVisibility = (items_array) => {
    //получем данные из state в массив
    let result = false
    for (let i=12; i<=23; i++){
        if(items_array[i].visibility)
            result = true
    }
    return result
}

const CheckTailVisibility = (items_array) => {
    //получем данные из state в массив
    let result = false
    for (let i=24; i<=35; i++){
        if(items_array[i].visibility)
            result = true
    }
    return result
}

///Этой функцией будем определять, куда возвращать фокус при загрузке новых данных
const getMinVisibleId = (items_array) => {
    let result = 0
    for (let i=1; i <= 35; i++){
        if(items_array[i].visibility){
            result = items_array[i].element_id
        }
    }
    return result
}

//Нам нужна функция, которая будет возвращать номер максимальной страницы, которая сейчас загружена в state
const getMaxPageNumber = (items_array) => {
    //на первом шаге получаем массив из state
    return (items_array[35].element_id + 1) / 12
}




export default function Home({items_array_statc}) {
    const dispatch = useDispatch()
    const [isLoading, setIsLoading] = useState(false)
    const items_array = useSelector(state => state.items_reducer.items_array)

    //Функция ждёт примерно пол секунды пока перерендерится страница,
    //после чего скроллит к последнему просмотренному элементу
    function go_to_valid(v_route){
        setTimeout(() => {
            // router.push(v_route);
            document.getElementById(v_route).scrollIntoView();   //.focus();
            setIsLoading(false)

        }, 600);
    }

    //Вставляем данные в state при первой загрузке окна
    useEffect(() => {
        setIsLoading(true)
        dispatch({type: "INSERT_ITEMS", payload: items_array_statc})
        setIsLoading(false)
    }, [])


    //Выполняется, когда обновляем данные в state - или когда изменяем видимость карточек, или когда подгружаем данные
     useEffect(() => {
         if (items_array.length > 0){
             //Ошибка случается, если последующий код выполняется из-за загрузки данных в массив. Нужно это исключить
             //Для этого использую isLoading: пока загрузка не закончилась и не произошёл скролл к нужному месту - не грузим новые данные
             if(CheckTailVisibility(items_array) && isLoading==false){
                 setIsLoading(true)
                 const min_visible_id = getMinVisibleId(items_array)
                 const max_page = getMaxPageNumber(items_array)
                 //загружаем данные в state
                 try {
                    dispatch(axiosFetchItems(12,max_page+1,'ADD_TO_TAIL'))
                    //скроллим к месту, где были до этого - и разблокируем дальнейшую загрузку
                    go_to_valid('card_'+min_visible_id)
                 } catch (exceptionVar) {
                     console.log("При загрузке данных произошла ошибка")
                     setIsLoading(false)
                 }
            }

             //То же самое, но когда прокрутка вверх
             if(CheckHeadVisibility(items_array) && isLoading==false){
                 const min_visible_id = getMinVisibleId(items_array)
                 const max_page = getMaxPageNumber(items_array)
                 if(max_page > 3){
                     setIsLoading(true)
                     try {
                         dispatch(axiosFetchItems(12, max_page - 3, 'ADD_TO_HEAD'))
                         go_to_valid('card_' + min_visible_id)
                     } catch (exceptionVar) {
                         console.log("При загрузке данных произошла ошибка")
                         setIsLoading(false)
                     }
                 }
             }
         }
     },[items_array]);


  return (
    <>
      <Head>
        <title>Тестовое для lichi</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className={`${styles.main} ${inter.className}`}>
        <div /*className={styles.description}*/>
                <div className={styles.cards}>
                    {items_array.map(item =>
                        <div>
                        {/*<p>{item.element_id}</p>*/}
                            <Card
                                  element_id ={item.element_id}
                                  name={item.name}
                                  article={item.article}
                                  price={item.price}
                                  description={item.description}
                                  img_link={item.img_link}
                                  isLoading={isLoading}
                                  key={item.element_id}
                            />
                        </div>
                    )}
                </div>
        </div>
      </main>
    </>
  )
}


export const getStaticProps = async () => {
    const response = await axios.get('https://api.lichi.com/category/get_category_product_list?' + new URLSearchParams({
        category: 'clothes',
        lang: 1,
        shop: 2,
        limit: 36,
        page: 1
    }))
    const data = response.data
    const data_array = data.api_data.aProduct
    let result_array = []
    for (let i=0; i<data_array.length; i++){
        const one_element = {
            // id: i ,
            element_id: i,
            visibility: false,
            name: data_array[i].name,
            article: data_array[i].article,
            price: data_array[i].original_price + data_array[i].currency.postfix,
            description: data_array[i].descriptions.html,
            img_link: data_array[i].photos[0].big
        }
        result_array.push(one_element)
    }

    return {
        props: {
            items_array_statc: result_array
        },
        revalidate: 60,
    }
}

